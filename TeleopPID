package org.firstinspires.ftc.teamcode;

import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DcMotorEx;
import com.qualcomm.robotcore.hardware.DcMotorSimple;
import com.qualcomm.robotcore.hardware.Servo;
import com.qualcomm.robotcore.util.ElapsedTime;

@TeleOp
public class TeleopPID extends LinearOpMode {

    // ==========================
    // Flywheel PID variables
    // ==========================
    double targetVelocity = 2000; // ticks/sec
    double kF = 0.00055;  // feedforward
    double kP = 0.00025;  // proportional
    double kI = 0.0;      // integral
    double kD = 0.0;      // derivative

    double integralSum = 0;
    double lastError = 0;
    long lastTime = 0;

    @Override
    public void runOpMode() {

        //=========== Initialize hardware ===========
        DcMotor frontLeftMotor = hardwareMap.dcMotor.get("leftFront");
        DcMotor backLeftMotor = hardwareMap.dcMotor.get("leftBack");
        DcMotor frontRightMotor = hardwareMap.dcMotor.get("rightFront");
        DcMotor backRightMotor = hardwareMap.dcMotor.get("rightBack");
        DcMotor intakeMotor = hardwareMap.dcMotor.get("intakeMotor");

        DcMotorEx launcherMotor = hardwareMap.get(DcMotorEx.class, "launcherMotor");
        launcherMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);

        Servo launcherServo = hardwareMap.servo.get("launcherServo");
        launcherServo.setPosition(0);

        ElapsedTime servoTimer = new ElapsedTime();
        boolean servoActive = false;
        double servoUpTime = 0.5;

        boolean dpadUpPrev = false;
        boolean dpadDownPrev = false;

        // Motor directions
        frontLeftMotor.setDirection(DcMotorSimple.Direction.REVERSE);
        backLeftMotor.setDirection(DcMotorSimple.Direction.REVERSE);
        frontRightMotor.setDirection(DcMotorSimple.Direction.FORWARD);
        backRightMotor.setDirection(DcMotorSimple.Direction.REVERSE);

        launcherMotor.setDirection(DcMotorSimple.Direction.FORWARD);

        // Brake drive, float flywheel
        frontLeftMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        backLeftMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        frontRightMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        backRightMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        launcherMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.FLOAT);

        waitForStart();

        while (opModeIsActive()) {

            // ==========================
            // Drive
            // ==========================
            double y = gamepad1.left_stick_y;
            double x = -gamepad1.left_stick_x;
            double rx = -gamepad1.right_stick_x;

            double denominator = Math.max(Math.abs(y) + Math.abs(x) + Math.abs(rx), 1);

            frontLeftMotor.setPower((y + x + rx) / denominator);
            backLeftMotor.setPower((y - x + rx) / denominator);
            frontRightMotor.setPower((y - x - rx) / denominator);
            backRightMotor.setPower((y + x - rx) / denominator);

            // ==========================
            // Flywheel target tuning
            // ==========================
            if (gamepad1.dpad_up && !dpadUpPrev) targetVelocity += 250;
            if (gamepad1.dpad_down && !dpadDownPrev) targetVelocity -= 250;

            dpadUpPrev = gamepad1.dpad_up;
            dpadDownPrev = gamepad1.dpad_down;

            targetVelocity = Math.max(0, Math.min(targetVelocity, 3000));

            // ==========================
            // Flywheel PID control
            // ==========================
            boolean shooterOn = gamepad1.right_trigger > 0.1;

            if (!shooterOn) {
                launcherMotor.setPower(0);
                integralSum = 0;
                lastError = 0;
                lastTime = System.nanoTime();
            } else {
                // Use motor's built-in velocity reading
                double currentVelocity = launcherMotor.getVelocity();
                // Correct for motor direction
                currentVelocity *= launcherMotor.getDirection() == DcMotorSimple.Direction.FORWARD ? 1 : -1;

                double error = targetVelocity - currentVelocity;

                long now = System.nanoTime();
                double dt = (now - lastTime) / 1e9;
                if (dt <= 0) dt = 1e-3;
                lastTime = now;

                integralSum += error * dt;
                integralSum = Math.max(-5000, Math.min(integralSum, 5000));

                double derivative = (error - lastError) / dt;
                lastError = error;

                double power = (kF * targetVelocity) + (kP * error) + (kI * integralSum) + (kD * derivative);
                power = Math.max(0, Math.min(power, 1));

                launcherMotor.setPower(power);

                telemetry.addData("Target Vel", targetVelocity);
                telemetry.addData("Current Vel", currentVelocity);
                telemetry.addData("Power", power);
            }

            // ==========================
            // Intake
            // ==========================
            if (gamepad1.left_trigger > 0.1) intakeMotor.setPower(1);
            else if (gamepad1.left_bumper) intakeMotor.setPower(-1);
            else intakeMotor.setPower(0);

            // ==========================
            // Launcher servo
            // ==========================
            if (gamepad1.right_bumper && !servoActive) {
                launcherServo.setPosition(0.2);
                servoTimer.reset();
                servoActive = true;
            }

            if (servoActive && servoTimer.seconds() >= servoUpTime) {
                launcherServo.setPosition(0.0);
                servoActive = false;
            }

            telemetry.update();
        }
    }
}
